#' Functions to get the WHO ICD-10 English 2016 and French 2008 data
#' @param resource Fragment of URL with specific ICD-10 resource requested
#' @param year Four-digit year as integer or character
#' @template lang
#' @return
#' \code{.who_api} returns the JSON data, or fails with NULL
#' @keywords internal datasets
#' @noRd
.who_api <- function(resource,
                     year = 2016,
                     lang = "en") {
  # WHO changed the URL from https://apps.who.int/classifications to
  # https://icd.who.int/browse10 . Nothing complicated: I set this (if unset) in
  # zzz.R on package load. If there is another change, the user can update this
  # with a package update.
  json_url <- paste(
    getOption("icd.data.who_url"),
    year,
    lang,
    resource,
    sep = "/"
  )
  if (.offline() && !.interact()) {
    msg <- "Offline and not interactive, so not attempting WHO data download."
    .absent_action_switch(msg)
    return(NULL)
  }
  .msg("Getting WHO data with JSON: ", json_url)
  http_response <- httr::RETRY("GET", json_url)
  if (hs <- http_response$status_code >= 400) {
    .msg("trying once more")
    http_response <- httr::RETRY("GET", json_url)
    if (hs <- http_response$status_code >= 400) {
      stop(
        "Unable to fetch resource: ", json_url,
        " with HTTP status, ", hs, ". Check your internet connection, ",
        "retry later, then file an issue at: ",
        "https://github.com/jackwasey/icd/issues ."
      )
    }
  } # end 400+
  json_data <- rawToChar(http_response$content)
  jsonlite::fromJSON(json_data)
}

#' Use WHO API to discover chapters
#'
#' Of note, the \code{WHO} package does not provide access to classifications, just
#' WHO summary data.
#' @keywords internal
#' @noRd
.who_api_chapter_names <- function(ver = "icd10",
                                   year = 2016,
                                   lang = "en") {
  .who_api_children(
    ver = ver,
    year = year,
    lang = lang
  )[["label"]]
}

#' Get the children of a concept (ICD-10 chapter, code or range)
#' @param concept_id NULl for root, concept string for any leaf or intermediate.
#' @examples
#' .who_api_children("XXII")
#' .who_api_children("U84")
#' # U85 is a leaf node, returns no children as empty list
#' .who_api_children("U82-U85")
#' # https://icd.who.int/browse10/2016/en#/U85
#' .who_api_children("U85")
#' # https://icd.who.int/browse10/2016/en#/P90
#' .who_api_children("P90-P96")
#' .who_api_children("P90")
#' @keywords internal
#' @noRd
.who_api_children <- function(concept_id = NULL, ...) {
  resource <- if (is.null(concept_id)) {
    "JsonGetRootConcepts?useHtml=false"
  } else {
    paste0(
      "JsonGetChildrenConcepts?ConceptId=",
      concept_id,
      "&useHtml=false"
    )
  }
  .who_api(resource = resource, ...)
}

#' Use public interface to fetch ICD-10 WHO data for a given version
#'
#' The user may call this function to install the full WHO ICD-10 definition on
#' their machine, after which it will be available to \CRANpkg{icd}.
#' @param concept_id This is the id for the code or code group, e.g.,
#'   \sQuote{XI} (Chapter 6), \sQuote{T90--T98} (A sub-chapter), \sQuote{E01} (A
#'   sub-sub-chapter). You cannot query a single code with this interface.
#' @param year integer 4-digit year
#' @param lang Currently it seems only 'en' works
#' @param ... further arguments passed to self recursively, or \code{.who_api}
#' @examples
#' .make_make_httr_retry()
#' .dl_icd10who(year = 2016, lang = "en", concept_id = "B20-B24")
#' @keywords internal
#' @noRd
.dl_icd10who <- function(concept_id = NULL,
                         year = 2016,
                         lang = "en",
                         progress = TRUE,
                         hier_code = character(),
                         hier_desc = character(),
                         parallel = TRUE,
                         ...) {
  if (parallel) {
    progress <- FALSE
    if (.verbose() > 1) {
      .dbg("Parallel WHO processing disabled with this verbosity level")
      parallel <- FALSE
    } else {
      .msg("Parallel WHO prevents messages in child processes")
    }
  }
    .dbg(
      ".who_api with concept_id = ",
      ifelse(is.null(concept_id), "NULL", concept_id)
    )
  .dbg(paste(hier_code, collapse = " -> "))
  if (.offline()) {
    .msg("Returning NULL because offline")
    return()
  }
  tree_json <- .who_api_children(
    concept_id = concept_id,
    year = year,
    lang = lang,
    ...
  )
  if (is.null(tree_json)) {
    warning(
      "Unable to retrieve results for concept_id: ", concept_id,
      "so returning NULL. Try re-running the command."
    )
    return()
  }
  .dbg("hier level = ", length(hier_code))
  new_hier <- length(hier_code) + 1
  # parallel mclapply is about 2-3x as fast, but may get throttled for multiple
  # connections. It seems to get up to about 10-15, which is reasonable.
  ap <- if (parallel) parallel::mclapply else lapply
  all_new_rows <- ap(
    seq_len(nrow(tree_json)),
    function(branch) {
      new_rows <- data.frame(
        code = character(),
        leaf = logical(),
        desc = character(),
        three_digit = character(),
        major = character(),
        sub_sub_chapter = character(),
        sub_chapter = character(),
        chapter = character()
      )
      # might be looping through chapters, sub-chapters, etc.
      child_code <- tree_json[branch, "ID"]
      child_desc <- tree_json[branch, "label"]
      is_leaf <- tree_json[branch, "isLeaf"]
      # for each level, if not defined by arguments, then assign next possible
      hier_code[new_hier] <- child_code
      hier_desc[new_hier] <- child_desc
      sub_sub_chapter <- NA
      hier_three_digit_idx <- which(nchar(hier_code) == 3 &
        !grepl("[XVI-]", hier_code))
      if (length(hier_code) >= 3 && nchar(hier_code[3]) > 3) {
        sub_sub_chapter <- hier_desc[3]
      }
      this_child_up_hier <- grepl("[XVI-]", child_code)
      three_digit <- hier_code[hier_three_digit_idx]
      major <- hier_desc[hier_three_digit_idx]
      if (!this_child_up_hier && !is.na(three_digit)) {
        new_item <- data.frame(
          code = child_code,
          leaf = is_leaf,
          desc = child_desc,
          three_digit = three_digit,
          major = major,
          sub_sub_chapter = sub_sub_chapter,
          sub_chapter = hier_desc[2],
          chapter = hier_desc[1],
          stringsAsFactors = FALSE
        )
        stopifnot(child_code %nin% new_rows$code)
        new_rows <- rbind(new_rows, new_item)
      }
      if (!is_leaf) {
          .dbg(
            paste(new_rows$code, collapse = ", "),
            " not a leaf, so recursing"
          )
        if (progress) cat(".")
        recursed_rows <- .dl_icd10who(
          concept_id = child_code,
          year = year,
          lang = lang,
          hier_code = hier_code,
          hier_desc = hier_desc,
          ...
        )
        stopifnot(!any(recursed_rows$code %in% new_rows$code))
        new_rows <- rbind(new_rows, recursed_rows)
      } # not leaf
      new_rows
    }
  ) # lapply loop
  if (.verbose() > 1) {
    .dbg("leaving recursion with length(all_new_rows) = ",
      length(all_new_rows)
    )
    if (length(all_new_rows$code)) {
      .trc(paste(all_new_rows$code, collapse = ", "), print = TRUE)
    }
  }
  # just return the rows (we are recursing so can't save anything in this
  # function). Parser can do this.
  if (progress) cat(fill = TRUE)
  do.call(rbind, all_new_rows)
}

.dl_icd10who_finalize <- function(dat, year, lang) {
  dat[["code"]] <- sub(pattern = "\\.", replacement = "", x = dat[["code"]])
  for (col_name in c(
    "chapter",
    "sub_chapter",
    "sub_sub_chapter",
    "major",
    "desc"
  )) {
    dat[[col_name]] <- sub("[^ ]+ ", "", dat[[col_name]])
  }
  # First, if three digit doesn't match code, then drop the row, as these are
  # incorrectly assimilated rows.
  thr <- get_major.icd10(dat$code)
  dat <- dat[dat$three_digit == thr, ]
  dat$three_digit <- factor_sorted_levels(as.icd10who(dat$three_digit))
  # Then I think any remaining rows are plain duplicates
  dat <- dat[!duplicated(dat$code), ]
  dat <- dat[order(dat$code), ]
  rownames(dat) <- NULL
  var_name <- paste0("icd10who", year, ifelse(lang == "en", "", lang))
  dat$code <- as.icd10who(dat$code)
  .save_in_resource_dir(var_name, x = dat)
  invisible(dat)
}

.parse_icd10who2016 <- function(...) {
  if (!.confirm_download()) return()
  .dl_icd10who_finalize(
    .dl_icd10who(year = 2016, lang = "en", ...),
    2016, "en"
  )
}

.parse_icd10who2008fr <- function(...) {
  if (!.confirm_download()) return()
  .dl_icd10who_finalize(
    .dl_icd10who(year = 2008, lang = "fr", ...),
    2008,
    "fr"
  )
}

.downloading_who_message <- function() {
  message("Downloading or parsing cached WHO ICD data. This may take a few minutes. Data is cached, so if there is a download error, repeating the instruction will return the data immediately if cached, or pick up where it left off.") # nolint
}
